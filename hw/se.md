#《高软》学习总结
《高级软件工程》这门课程提供了一种发展的视角，例如如何利用工具来提升开发效率、如何从“零”构建一个有意义的实际项目、如何应用工程化方法完成分析与设计、如何促进个人与团队的成长

## 一、开发工具
在程序员的职业生涯中总是需要与代码打交道的，掌握一些开发技巧与工具能提高开发效率，比如git、vim、regex、vscode、typing

### 1. git
- commit是git的核心数据结构
- commit可视作 增量补丁（基于line diff）的集合
- branch可视作 指向commit的指针
- HEAD可视作指向commit的指针的指针（HEAD也可以直接指向commit），其指向的commit作为下一次commit的父结点
- 工作区（Working Directory）可视作正在构建中的commit，暂存区（Index）可视作已构建完成的commit但尚未写入commits
- 重置（git reset --[hard|mixed|sort]) 可视作对三棵“树“（HEAD、Index、WD）作commit指针的移动
- reset和checkout主要的区别是checkout只移动HEAD指针，而reset还会移动HEAD指向的指针

### 2. regex
- . ? + *
- {m , n}, {m}
- [^a-zA-Z0-9]
- \w = [A-Za-z0-9_]
  - \W = [^A-Za-z0-9_]
- \d = [0-9]
  - \D = [^0-9]
- 懒惰匹配 *?
- 位置 ^ $
- 捕获组 (regex)，复用 \1 \2 ...，替换 $1 $2 ...
``` regex
-- 将html<h\d>改成<H\d>
1,$s/<h(\d)>/<H$1>/g
```

## 二、工程化编程
这部分内容提供了一种开发软件的视角，即软件可以从hello
world（或者一个小的可运行系统）开始不断迭代调试构筑起来

### 1. 模块化
- 分而治之
- 使用耦合度（coupling）和内聚度（cohesion）来衡量模块化程度
- 无耦合（0）、松散耦合（m）、紧密耦合（m^2)

### 2. 可重用
- 设计合适的接口
  - 接口具体定义了软件模块对系统的其他部分提供怎样的服务，以及系统的其他部分如何访问所提供的服务
  - 并非所有接口都要设计的通用，通用往往意味着接口不够直接，要依据所提供的服务来设计
- 接口规格五要素
  - 接口目的
  - 前置条件
  - 协议规范
  - 后置条件
  - 质量属性（时间、空间复杂度）
- 接口与耦合度
  - 公共耦合：模块间共享数据区或变量名
  - 数据耦合：模块间仅通过显示调用传递基本数据结构
  - 标记耦合：模块间仅通过显示调用传递复杂数据结构，此时数据结构成为调用双方软件模块的规格约定

### 3. 微服务架构
- 单体集中式架构
- 微服务架构
  - 由一系列独立的微服务共同组成软件系统
  - 每个微服务单独部署
  - 通过RESTful API接口方式进行封装
  - 各微服务之间无耦合或者松散耦合，系统通过前端应用或者API网关来聚合各微服务
- RESTful API
  - 分离资源与操作，以往需要将API定义为诸如GETResourceA，复杂度由 m * n 降低为 m + n
  - URI
  - GET, POST, PUT, DELETE

## 三、 需求分析与设计
- 需求是（用户）期望行为的（软件）表述
  - 用对象或实体的状态、属性和行为来定义需求
- 需求类型
  - 功能需求
  - 质量需求
  - 设计约束
  - 过程约束
- 高质量需求
  - 需求可测
  - 解决冲突
  - 需求特征

### 1. 需求分析
- 整理需求的方法：1.原型化 2.建模
- 原型化方法可以整理出UI，比如界面布局和交互操作过程
- 建模的方法可以给出有关事件发生顺序或活动同步约束的问题

### 2. 用例
用例是一个业务过程，在待开发软件所处的业务领域内完成特定业务任务的一系列活动就是业务过程

#### 2.1 用例基本要素
- 一个用例由业务领域内的某个Actor所触发
- 用例必须为Actor完成一个特定的业务任务
- actor明确或者隐含地得到了业务任务完成的结果
  - actor不是待开发软件系统的一部分，但参与者需要和待开发软件系统交互
  - actor可以是人，也可以是一个外部的硬件或软件
  - 用例为actor完成一个业务任务

#### 2.2 用例抽象层级
- 抽象用例：完成什么业务的动名词
- 高层用例：给用例的范围划定边界，何时何地开始，何时何地结束
- 扩展用例：使用一个两列的表格描述actor与软件系统的交互步骤

#### 2.3 提取用例的基本方法
- 从需求中寻找业务领域相关的动名词和动名词短语
- 验证是不是用例
  - 是不是一个业务过程？
  - 是不是由某个actor触发开始？
  - 是不是显式或隐式终止于某个actor？
  - 是不是为某个actor完成了有用的业务工作？
- 在需求中识别出actor、系统或子系统

### 3. 业务领域建模
业务领域建模是开发团队用于获取业务领域知识的过程
- 收集应用业务领域信息，聚焦功能需求
- 头脑风暴，列出用用业务领域概念，给出这些概念的属性，以及概念之间的关系
  - 名词和名词短语
    - 类或者属性
  - X of Y
    - X可能是Y的属性
  - 及物动词
    - 关联
  - 形容词
    - 属性值
  - 数量词
    - 属性或属性值
  - 所有关系的表达方法
    - 聚合关系或属性
  - 构成关系的表达方法
    - 聚合关系
  - 包含关系的表达方法
    - 关联关系或聚合关系
  - X is a Y
    - 继承关系
- 给这些概念分类，列出哪些是类、属性、属性值，类之间的集成关系、聚合关系和关联关系
- 将结果用UML类图画出来

### 4. 需求分析产出
- 用例图
- uml类图
- 数据模型（数据库设计）

### 5. 业务概念原型
业务概念原型 = 用例 + 数据模型

### 6. 设计
- 瀑布模型
  - 需求、分析、编码、测试、部署
- 统一过程
  - 用例驱动
  - 架构为中心
  - 增量迭代

### 7. 敏捷统一过程
- 确定需求
- 通过用例的方式来满足这些需求
- 分配这些用例到各增量阶段
- 具体完成各增量阶段所计划的任务

在每一次增量阶段的迭代过程中，都要进行从需求分析到软件设计实现的过程
- 用例建模
- 业务领域建模
- 对象交互建模
  - 以某个用例的扩展用例为输入
  - 找出关键步骤进行 剧情描述
    - 在扩展用例右侧一列中找出关键步骤，关键步骤是那些需要在背后进行业务过程处理的步骤，而不是接口层面交互的琐碎步骤
  - 将 剧情描述 转换成 剧情描述表
    - 对于每一个关键步骤，从关键步骤在扩展用例两列表格中的左侧作为开始，完成剧情描述，描述一步一步的对象交互过程
    - 进一步转换成剧情描述表
    - 剧情描述表是一个五列表格：序号、主体、谓语动词、谓语动词所需的其他对象、谓语动词作用的对象宾语
  - 将 剧情描述表 转换成 序列图（时序图）
  - 分析序列图到设计序列图
    - 分析是对业务领域建模，设计是对待开发的软件系统建模
    - 分析是对应用业务实际情况的描述，业务实际情况是客观存在的；设计是待开发的软件解决方案如何实现应用业务的说明
- 形成设计类图
- 软件编码实现和部署

## 四、软件系统设计
“开发软件的根本任务是打造构成抽象软件的复杂概念结构，次要任务才是使用代码表达抽象的概念设计并映射成机器指令。”

### 1. 设计模式
- 区分变化的部分和不变的部分，对变化的部分应用设计模式
- 设计模式的原则比模式更重要
  - OCP
  - LSP
  - DIP
  - SRP
  - LoD
  - CRP

### 2. 架构
- 三层架构
  - 界面层
  - 业务逻辑层
  - 数据访问层
- MVC
  - model
  - view
  - controller
- MVVM

### 3. 软件架构模型
- 软件架构模型是在高层抽象上对系统中关键要素的描述，而且表现出抽象的层次结构。
- 构建软件架构模型的基本方法就是在不同层次上分解（decomposition）系统并抽象出其中的关键要素
- 分解
  - 面向功能的分解方法，用例建模即是一种面向功能的分解方法
  - 面向特征的分解方法，根据数量众多的某种系统显著特征在不同抽象层次上划分模块的方法
  - 面向数据的分解方法，在业务领域建模中形成概念业务数据模型即应用了面向数据的分解方法
  - 面向事件的分解方法，当系统中需要处理大量的事件，而且往往事件会触发复杂的状态转换关系，这时系统就要考虑面向事件的分解方法，并内在状态转换关系进行清晰的描述
  - 面向对象的分解方法，是一种通用的分析设计范式，是基于系统中抽象的对象元素在不同抽象层次上分解的系统的方法

## 五、软件危机
### 1. 表现
大型软件工程中的根本问题是难以汇聚众多参与人员的设计理念形成完整的、一致的复杂软件概念结构
- 代码总是错的，越陷越深的bug链
- 需求总是变化的，影响代码结构
- 团队难以达成软件概念的一致性

### 2. 软件概念结构
- 软件要解决什么问题？ 怎么分解的？
- 软件概念结构
  - 难以解决软件概念结构的复杂性，无法达成复杂软件概念的完整性和一致性
- 基于规则的编程模型
- 基于联结的编程模型

### 3. 软件过程模型
生命周期： 分析、设计、实现、交付和维护

- 分析
  - 形成业务概念原型：业务功能、业务数据模型
    - 比如用例的集合、业务数据模型，每一个用例在逻辑上都可以通过操作业务数据模型完成关键的业务过程
- 设计
  - 软件架构设计、软件详细设计
  - 软件架构设计，分析与设计，结果：概念上的软件有机统一体，称之为系统概念原型
  - 软件详细设计，设计与实现
- 实现
  - 编码、测试
  - 单元测试、集成测试、系统测试
- 交付
  - 部署、交付测试、人员培训
- 维护

即
- 形成软件的业务概念原型
- 形成系统概念原型
- 实现、交付、维护


### 4. 软件（开发）过程模型
- 瀑布模型
  - 完全理解需求，且需求不会发生变更
  - 顺序结构，没有任何迭代
- 原型化的瀑布模型
  - 原型：根据需要完成的软件最核心的那一部分
- V模型
  - “未定生，先定死“
  - 需求分析  <-确认需求-> 交付测试
  - 系统设计 <-验证设计-> 系统测试
  - 程序设计 <---> 单元测试和集成测试
- 分阶段的增量和迭代开发过程
  - 分阶段分两种：1. 增量 2. 迭代
  - 增量
    - 一开始就做出功能子系统
    - 每次交付增加一些功能
  - 迭代
    - 首先完成一个完整的系统或者完整系统的框架
    - 每次交付升级其中某个功能子系统
- 螺旋模型

### 5. CMM
- 软件组织对项目的目标与要做的努力很清晰，项目的目标可以实现
- 软件组织在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对项目相关的实施人员进行了相应的培训，对整个流程进行监测与控制，并联合上级单位对项目与流程进行审查
- 软件组织能够根据自身的特殊情况及自己的标准流程，将这套管理体系与流程予以制度化
- 软件组织的项目管理实现了数字化
- 软件组织能够充分利用信息资料，对软件组织在项目实施的过程中可能出现的问题予以预防。能够主动地改善流程，运用新技术，实现流程的优化。

CMM/CMMI不仅是一个模型，一个工具，它更代表了一种管理哲学在软件工业中的应用（开发管理与经验也是企业的宝贵资产）

### 6. 软件过程评估和软件能力评价
- 软件过程评估集中关注组织自身的软件过程
- 软件能力评价集中关注识别在预算和进度要求范围内完成开发出高质量的软件产品的软件合同及相关风险。评价在一种审核的环境中进行，重点在于揭示组织实际执行软件过程的文档化的审核记录。

### 7. 独立开发维护
- 了解情况和需要解决的问题
- 找出解决方案
- 估算完成哪些工作
- 与客户沟通建议方案
- 开始行动完成工作
- 对产出结果的质量负责

### 8. PSP
计划、执行、总结
0 计划阶段  
  2 项目评估  
0 开发阶段  
  5 分析  
  5 设计规格  
  1 编码标准规范  
  0 设计  
  4 设计评审  
  0 编码  
  4 代码评审  
  0 测试  
3 统计记录各项工作用了多少时间  
2 项目测试报告  
1 程序规模度量  
0 开发完成后进行总结分析  
1 过程改进计划  

分配、协调、跟踪、汇报

## 总结
以对象作为基本元素构建起来了一种主流的看待软件的范型，形成了从编程语言、UML、开发方法、设计模式、软件架构以及工程思想方法等一系列成果


 参考资料：
 《代码中的软件工程》
